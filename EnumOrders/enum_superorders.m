// Functions to enumerate superorders of a given quaternion order,
// possibly picking out a given class of orders.

function IsIntegral(R,x)
    return Norm(x) in R and Trace(x) in R;
end function;

function AdjoinElement(O, x)
    // Return the smallest overorder containing O and x.
    if not IsIntegral(BaseRing(O), x) then
        return false, _;
    end if;

    // We are lazy - we simply take the O-ideal I generated by O and x,
    // and, while I is not an order replace it by I^2
    I := rideal<O | Generators(O) cat [x]>;
    while not rideal<O | Generators(RightOrder(I))> eq I do
        gens := Generators(I);
        for x in gens do
            if not IsIntegral(BaseRing(O), x) then
                return false, _;
            end if;
        end for;

        J := rideal< O | gens cat [x*y : x,y in gens ] >;
        assert not (I eq J);
        I := J;
    end while;

    return true, RightOrder(I);
end function;

function MinimalSuperordersAtP(O, p, Selector : UpTo := "Isomorphism")
    // Given an order O and a prime ideal p, compute all orders
    // O' such that
    // *) O ⊊ O' and O' is minimal with this property
    // *) O and O' only differ at p
    //
    // By a result of Brzezinski, [O':O] <= p^2 and pO' ⊆ O.
    //
    // any *minimal* such overorder can obviously be generated by
    // adjoining a single element.
    //
    // The parameter UpTo selects if orders should be enumerated up to
    // "Equality", "Isomorphism", or "LocalIsomorphism"

    A:= Algebra(O);

    B:= LocalBasis(O, p : Type := "Submodule");
    pO:= [g*b : b in Generators(O), g in Generators(p)];

    if UpTo eq "Equality" then
        cmpfunc := func< O1, O2, p | O1 eq O2 >;
    elif UpTo eq "LocalIsomorphism" then
        cmpfunc := func< O1, O2, p | IsLocallyIsomorphic(O1, O2, p)>;
    else // default is up to global isomorphism
        cmpfunc := func< O1, O2, p | IsConjugate(O1, O2 : FindElement := false)>;
    end if;

    Omodp, h := ResidueRing(O, p);

    pi := UniformizingElement(p);

    // We first enumerate orders up to equality, because we need to check
    // minimality. Only later do we reduce according to 'UpTo'.
    L := [];
    for extra_gen in Omodp do
        works, OO := AdjoinElement(O, (extra_gen @@ h) / pi);
        if not works then
            continue;
        end if;

        if not(OO eq O) and Selector(OO) then
            // Compare this order to the ones already seen
            gens := Generators(OO);

            for i:=#L to 1 by -1 do // looping backwards because we are removing elements
                Oseen := L[i];
                if forall { y : y in Generators(Oseen) | y in OO } then
                    // We have already seen a suborder of OO;
                    // throw away this order
                    continue extra_gen;
                end if;

                if forall { x : x in gens | x in Oseen } then
                    // We have seen a *superorder* of the current one that is
                    // not equal. That means the old order should be removed
                    // (and we are adding the smaller one later)

                    Remove(~L, i);
                end if;
            end for;

            Append(~L, OO);
        end if;
    end for;

    if UpTo eq "Equality" then
        L2 := L;
    else
        L2 := [];
        for OO in L do
            if forall{l : l in L2 | not cmpfunc(OO, l, p)} then
                Append(~L2, OO);
            end if;
        end for;
    end if;

    return L2;
end function;

intrinsic EnumerateSuperordersAtP(O::AlgAssVOrd, p::RngOrdIdl
                                 : UpTo := "LocalIsomorphism") -> GrphDir
    { Enumerate all superorders of O at prime p.

      Orders will be returned in the form of a graph. Retrieve orders as
      labels of vertices. A directed edge from V1 to V2 means that V2 is
      a minimal overorder of V1

      UpTo ... "Isomorphism" or "LocalIsomorphism"
    }

    assert (UpTo eq "Equality") or (UpTo eq "Isomorphism") or (UpTo eq "LocalIsomorphism");

    if UpTo eq "Equality" then
        cmpfunc := func< O1, O2, p | O1 eq O2 >;
    elif UpTo eq "LocalIsomorphism" then
        cmpfunc := func< O1, O2, p | IsLocallyIsomorphic(O1, O2, p)>;
    else // default is up to global isomorphism
        cmpfunc := func< O1, O2, p | IsConjugate(O1, O2 : FindElement := false)>;
    end if;

    G := Digraph<1 | >;
    v := VertexSet(G) . 1;
    AssignLabel(~G, v, O);

    current := [ <O,1> ];

    A := Algebra(O);

    // We enumerate up to Equality at first, since we will then check up to
    // isomorphism across all orders of the same level (result will *not* be a tree!)

    // TODO: could optimize comparison with seen orders by index
    seen := current;

    repeat
        next_level := [ ];
        for OO in current do
            OO_order := OO[1];
            OO_vertex := OO[2];
            superorders := MinimalSuperordersAtP(OO_order, p,
                                                 func<O|true> : UpTo := "Equality");

            for Onew in superorders do
                // If we have seen this order already, simply add a corresponding edge
                need_to_insert := true;
                for Oseen in seen do
                    Oseen_order := Oseen[1];
                    Oseen_vertex := Oseen[2];
                    if cmpfunc(Oseen_order, Onew, p) eq true then
                        need_to_insert := false;
                        break;
                    end if;
                end for;

                if need_to_insert then
                    // We haven't seen this order yet! We need to create a new vertex first.
                    AddVertex(~G);
                    Vnew := VertexSet(G);

                    Oseen_order := Onew;
                    Oseen_vertex := #Vnew;

                    AssignLabel(~G, Vnew . Oseen_vertex, Oseen_order);

                    Append(~next_level, < Oseen_order, Oseen_vertex >);
                    Append(~seen, < Oseen_order, Oseen_vertex >);
                end if;

                // Either way, add an edge between these orders
                Vnew := VertexSet(G);
                AddEdge(~G, Vnew . OO_vertex, Vnew . Oseen_vertex);
            end for;
        end for;

        current := next_level;
    until #next_level eq 0;

    return G;
end intrinsic;
